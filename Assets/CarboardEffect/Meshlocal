using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.UIElements;

using System.Collections;
using System.Collections.Generic;
using System;

public class AdjacencyList<K>
{
    private List<List<K>> _vertexList = new List<List<K>>();
    private Dictionary<K, List<K>> _vertexDict = new Dictionary<K, List<K>>();

    public AdjacencyList(K rootVertexKey)
    {
        AddVertex(rootVertexKey);
    }

    private List<K> AddVertex(K key)
    {
        List<K> vertex = new List<K>();
        _vertexList.Add(vertex);
        _vertexDict.Add(key, vertex);

        return vertex;
    }

    public void AddEdge(K startKey, K endKey)
    {
        List<K> startVertex = _vertexDict.ContainsKey(startKey) ? _vertexDict[startKey] : null;
        List<K> endVertex = _vertexDict.ContainsKey(endKey) ? _vertexDict[endKey] : null;

        if (startVertex == null)
            throw new ArgumentException("Cannot create edge from a non-existent start vertex.");

        if (endVertex == null)
            endVertex = AddVertex(endKey);

        startVertex.Add(endKey);
        endVertex.Add(startKey);
    }

    public void RemoveVertex(K key)
    {
        List<K> vertex = _vertexDict[key];

        //First remove the edges / adjacency entries
        int vertexNumAdjacent = vertex.Count;
        for (int i = 0; i < vertexNumAdjacent; i++)
        {
            K neighbourVertexKey = vertex[i];
            RemoveEdge(key, neighbourVertexKey);
        }

        //Lastly remove the vertex / adj. list
        _vertexList.Remove(vertex);
        _vertexDict.Remove(key);
    }

    public void RemoveEdge(K startKey, K endKey)
    {
        ((List<K>)_vertexDict[startKey]).Remove(endKey);
        ((List<K>)_vertexDict[endKey]).Remove(startKey);
    }

    public bool Contains(K key)
    {
        return _vertexDict.ContainsKey(key);
    }

    public int VertexDegree(K key)
    {
        return _vertexDict[key].Count;
    }
}
public class MeshConnectedComponents
{
    public List<int> vertexComponentIds;
    public int numComponents;
}

public class MeshBuildingData
{
    public List<Vector3> verts;
    public List<Vector2> uvs;
    public List<int> triangle_indices;
    public int next_id = 0;
}

public class CutterMesh : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {

    }

    private MeshConnectedComponents ComputeConnectedComponentsAfterCut(Mesh mesh, Vector3 cutting_point,
        Vector3 cutting_normal)
    {
        MeshConnectedComponents res = new MeshConnectedComponents();
        // todo: implement graph search

        AdjacencyList<int> adjacencyList = new AdjacencyList<int>();

        // Ã¼ber jedes Dreieck iterieren
        for (int i = 0; i < mesh.triangles.Length; i += 3)
        {
            Vector3 corner1 = mesh.vertices[mesh.triangles[i]] - cutting_point;
            Vector3 corner2 = mesh.vertices[mesh.triangles[i + 1]] - cutting_point;
            Vector3 corner3 = mesh.vertices[mesh.triangles[i + 2]] - cutting_point;

            float dot1 = Vector3.Dot(corner1, cutting_normal);
            float dot2 = Vector3.Dot(corner2, cutting_normal);
            float dot3 = Vector3.Dot(corner3, cutting_normal);
            float sign1 = Mathf.Sign(dot1);
            float sign2 = Mathf.Sign(dot2);
            float sign3 = Mathf.Sign(dot3);

            if (sign1 == sign2 && sign1 != sign3)
            {
                adjacencyList.AddEdge(mesh.triangles[i], mesh.triangles[i + 1])
                continue
            }

            if (sign1 == sign3 && sign1 != sign2)
            {
                adjacencyList.AddEdge(mesh.triangles[i], mesh.triangles[i + 2])
                continue
            }

            adjacencyList.AddEdge(mesh.triangles[i], mesh.triangles[i + 1])
            adjacencyList.AddEdge(mesh.triangles[i + 1], mesh.triangles[i + 2])
            adjacencyList.AddEdge(mesh.triangles[i], mesh.triangles[i + 2])
        }

        // do BFS to find components
        // Mark all the vertices as not visited
        bool[] visited = new bool[vertices.Length];
        for (int i = 0; i < vertices.Length; i++)
            visited[i] = false;

        // save vertexComponentindex
        int[] componentIndex = new int[vertices.Length];

        // Create a queue for BFS
        Queue<int> queue = new Queue<int>();


        int index_vertex = 0;
        int component = 0;

        // Mark the current node as
        // visited and enqueue it
        visited[index_vertex] = true;
        queue.Enqueue(index_vertex);

        while (index < mesh.vertices.Length)
        {

            while (queue.Any())
            {

                // Dequeue a vertex from queue
                // and print it
                s = queue.First();
                Console.Write(s + " ");
                queue.Dequeue();

                // Get all adjacent vertices of the
                // dequeued vertex s. If a adjacent
                // has not been visited, then mark it
                // visited and enqueue it
                AdjacencyList<int> list = adjacencyList[s];

                foreach (var val in list)
                {
                    if (!visited[val])
                    {
                        visited[val] = true;
                        queue.Enqueue(val);
                        componentIndex[val] = component
                    }
                }
            }

            while (visited[index_vertex])
            {
                index_vertex++
            }
            visited[index_vertex] = true;
            queue.Enqueue(index_vertex);

            component++

        }

        res.vertexComponentIds = component
        res.vertexComponentIds = componentIndex

        return res;
    }

    private void cutMesh(Mesh mesh, Vector3 cutting_point, Vector3 cutting_normal)
    {
        MeshConnectedComponents component_prediction = ComputeConnectedComponentsAfterCut(mesh, cutting_point, cutting_normal);

        List<MeshBuildingData> mesh_data = new List<MeshBuildingData>(component_prediction.numComponents);

        // wtf why so bad c#
        List<int> old_to_new_ids = new List<int>();
        for (int i = 0; i < mesh.vertexCount; i++)
        {
            old_to_new_ids.Add(-1);
        }

        for (int i = 0; i < mesh.triangles.Length; i += 3)
        {
            Vector3 corner1 = mesh.vertices[mesh.triangles[i]] - cutting_point;
            Vector3 corner2 = mesh.vertices[mesh.triangles[i + 1]] - cutting_point;
            Vector3 corner3 = mesh.vertices[mesh.triangles[i + 2]] - cutting_point;

            Vector3[] corners = { corner1, corner2, corner3 };
            int[] ids = { mesh.triangles[i], mesh.triangles[i + 1], mesh.triangles[i + 2] };
            Vector2[] uvs = { mesh.uv[ids[0]], mesh.uv[ids[1]], mesh.uv[ids[2]] };

            float dot1 = Vector3.Dot(corner1, cutting_normal);
            float dot2 = Vector3.Dot(corner2, cutting_normal);
            float dot3 = Vector3.Dot(corner3, cutting_normal);
            float sign1 = Mathf.Sign(dot1);
            float sign2 = Mathf.Sign(dot2);
            float sign3 = Mathf.Sign(dot3);

            float[] signs = { sign1, sign2, sign3 };

            // add the triangle to one of the meshes
            if (sign1 == sign2 && sign1 == sign3)
            {
                int active_component = component_prediction.vertexComponentIds[ids[0]];
                // add new vertices
                for (int j = 0; j < 3; j++)
                {
                    if (old_to_new_ids[ids[j]] == -1)
                    {
                        old_to_new_ids[ids[j]] = mesh_data[active_component].next_id;
                        mesh_data[active_component].next_id += 1;
                        // create vertex
                        mesh_data[active_component].verts.Add(corners[j]);
                    }
                    // create triangle
                    mesh_data[active_component].triangle_indices.Add(old_to_new_ids[ids[j]]);
                    // create uvs
                    mesh_data[active_component].uvs.Add(uvs[j]);
                }
                continue;
            }

            int one_side_index = 0;

            if (sign1 == sign2)
            {
                one_side_index = 2;
            }

            if (sign1 == sign3)
            {
                one_side_index = 1;
            }

            Vector3 intersection1 = compute_intersection(corners[one_side_index], corners[one_side_index + 2 % 3], cutting_normal);
            Vector3 intersection2 = compute_intersection(corners[one_side_index], corners[one_side_index + 1 % 3], cutting_normal);

            if (signs[one_side_index] < 0)
            {
                continue;
            }



            // erstelle neue Dreiecke mit den Schnittpunkten
        }
    }

    private Vector3 compute_intersection(Vector3 point1, Vector3 point2, Vector3 normal)
    {
        Vector3 distance = Vector3.Normalize(point1 - point2);
        return point1 + distance * (-Vector3.Dot(point1, normal) / Vector3.Dot(distance, normal));
    }

}
